1 Gauss
import numpy as np
import matplotlib.pyplot as plt

# Substitusi mundur
n = len(A)
x = np.zeros(n)  # definisikan x dulu

for i in range(n-1, -1, -1):
    x[i] = (A[i][-1] - np.sum(A[i][i+1:n] * x[i+1:n])) / A[i][i]

print("\nHasil akhir:")
print(f"x = {x[0]:.2f}")
print(f"y = {x[1]:.2f}")
print(f"z = {x[2]:.2f}")

# GRAFIK 3D Bidang dari 3 Persamaan

x_vals = np.linspace(-5, 5, 30)
y_vals = np.linspace(-5, 5, 30)
X, Y = np.meshgrid(x_vals, y_vals)

# Persamaan bidang

Z1 = (0 - 1*X + 1*Y) / -1      # dari x - y + z = 0
Z2 = (5 - 3*X - 2*Y) / -2      # dari 3x + 2y - 2z = 5
Z3 = (4 - 1*X - 3*Y) / 3       # dari x + 3y + 3z = 4

fig = plt.figure(figsize=(8,6))
ax = fig.add_subplot(111, projection='3d')

# Gambar bidang
ax.plot_surface(X, Y, Z1, alpha=0.5, color='red', label='x - y + z = 0')
ax.plot_surface(X, Y, Z2, alpha=0.5, color='green', label='3x + 2y - 2z = 5')
ax.plot_surface(X, Y, Z3, alpha=0.5, color='blue', label='x + 3y + 3z = 4')

# Titik hasil perpotongan (solusi)
ax.scatter(x[0], x[1], x[2], color='black', s=60, label='Solusi (Titik Potong)')

ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')
ax.set_title('Grafik 3D Sistem Persamaan Linear')

plt.legend()
plt.show()

2.gauss

import numpy as np
import matplotlib.pyplot as plt

# Substitusi Mundur
x = np.zeros(n)
for i in range(n-1, -1, -1):
    x[i] = (Ab[i][-1] - np.sum(Ab[i][i+1:n] * x[i+1:n])) / Ab[i][i]

print("\nHasil akhir:")
print(f"x = {x[0]:.2f}")
print(f"y = {x[1]:.2f}")
print(f"z = {x[2]:.2f}")

# Grafik 3D Bidang Persamaan

x_vals = np.linspace(-5, 5, 30)
y_vals = np.linspace(-5, 5, 30)
X, Y = np.meshgrid(x_vals, y_vals)

# Bentuk Z dari masing-masing persamaan
Z1 = (9 - 2*X - 1*Y) / 1      # dari 2x + y + z = 9
Z2 = (6 - 1*X - 1*Y) / 1      # dari x + y + z = 6
Z3 = (7 - 3*X + 1*Y) / 2      # dari 3x - y + 2z = 7

fig = plt.figure(figsize=(8,6))
ax = fig.add_subplot(111, projection='3d')

# Gambar bidang
ax.plot_surface(X, Y, Z1, alpha=0.5, color='red', label='2x + y + z = 9')
ax.plot_surface(X, Y, Z2, alpha=0.5, color='green', label='x + y + z = 6')
ax.plot_surface(X, Y, Z3, alpha=0.5, color='blue', label='3x - y + 2z = 7')

# Titik hasil perpotongan (solusi)
ax.scatter(x[0], x[1], x[2], color='black', s=60, label='Solusi (Titik Potong)')

ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')
ax.set_title('Grafik 3D Sistem Persamaan Linear')

plt.legend()
plt.show()

3.LU

import numpy as np

# Fungsi untuk LU Decomposition (tanpa pivot)

def lu_decomposition(A):
    n = len(A)
    L = np.zeros((n, n), float)  # Matriks segitiga bawah
    U = np.zeros((n, n), float)  # Matriks segitiga atas

    # Inisialisasi awal
    U[:, :] = A.copy()
    for i in range(n):
        L[i][i] = 1  # Diagonal L selalu 1

    # Proses eliminasi Gauss untuk membentuk L dan U
    for k in range(n):
        for i in range(k + 1, n):
            factor = U[i][k] / U[k][k]  # Faktor pembagi
            L[i][k] = factor            # Simpan ke L
            U[i, k:] -= factor * U[k, k:]  # Kurangi baris di U

    return L, U


# Fungsi Forward Substitution (Ly = b)

def forward_substitution(L, b):
    n = len(b)
    y = np.zeros(n)

    for i in range(n):
        y[i] = b[i] - np.dot(L[i, :i], y[:i])
        y[i] /= L[i][i]  # Karena diagonal L = 1, ini bisa di-skip

    return y

# Fungsi Backward Substitution (Ux = y)

def backward_substitution(U, y):
    n = len(y)
    x = np.zeros(n)

    for i in range(n - 1, -1, -1):
        x[i] = y[i] - np.dot(U[i, i + 1:], x[i + 1:])
        x[i] /= U[i][i]

    return x


# SOAL NOMER 3

A = np.array([
    [1, 2, 1],
    [2, 1, 3],
    [3, 1, 2]
], dtype=float)

b = np.array([8, 13, 12], float)

# Proses LU Decomposition
L, U = lu_decomposition(A)

# Selesaikan Ly = b
y = forward_substitution(L, b)

# Selesaikan Ux = y
x = backward_substitution(U, y)


# OUTPUT

print("=== Penyelesaian dengan Metode LU ===")
print("\nMatriks L (Lower Triangular):\n", L)
print("\nMatriks U (Upper Triangular):\n", U)
print("\nSolusi [x, y, z]:\n", x)

4.LU
import numpy as np

# Fungsi LU Decomposition

def lu_decomposition(A):
    n = len(A)
    L = np.zeros((n, n), float)
    U = np.zeros((n, n), float)

    # Inisialisasi
    U[:, :] = A.copy()
    for i in range(n):
        L[i][i] = 1

    # Proses eliminasi
    for k in range(n):
        for i in range(k+1, n):
            factor = U[i][k] / U[k][k]
            L[i][k] = factor
            U[i, k:] -= factor * U[k, k:]

    return L, U


# Forward Substitution Ly = b

def forward_substitution(L, b):
    n = len(b)
    y = np.zeros(n)

    for i in range(n):
        y[i] = b[i] - np.dot(L[i, :i], y[:i])
        y[i] /= L[i][i]

    return y

# Backward Substitution Ux = y

def backward_substitution(U, y):
    n = len(y)
    x = np.zeros(n)

    for i in range(n-1, -1, -1):
        x[i] = y[i] - np.dot(U[i, i+1:], x[i+1:])
        x[i] /= U[i][i]

    return x


# SOAL NOMOR 4


A = np.array([
    [1, 1, 1],
    [2, 4, 2],
    [-1, 3, 2]
], dtype=float)

b = np.array([6, 16, 9], float)

# LU DECOMPOSITION
L, U = lu_decomposition(A)

# Forward & Backward Substitution
y = forward_substitution(L, b)
x = backward_substitution(U, y)

# OUTPUT
print("=== Penyelesaian Soal Nomor 4 ===")
print("\nMatriks L:\n", L)
print("\nMatriks U:\n", U)
print("\nSolusi x, y, z =\n", x)
